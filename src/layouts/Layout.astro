---
export interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Chris wird 50 â€” 19. September 2026, Hamburg" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@300;400;500&family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <title>{title}</title>
  </head>
  <body class="overflow-x-hidden bg-[#f4f1ec] text-[#1a1d2e] font-['Inter',sans-serif] grain">
    <slot />
    <script>
      import Lenis from 'lenis';
      import { gsap } from 'gsap';
      import { ScrollTrigger } from 'gsap/ScrollTrigger';

      gsap.registerPlugin(ScrollTrigger);

      // Smooth scroll
      const lenis = new Lenis({
        duration: 1.0,
        easing: (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
        smoothWheel: true,
        lerp: 0.1,
      });

      lenis.on('scroll', ScrollTrigger.update);
      gsap.ticker.add((time) => lenis.raf(time * 1000));
      gsap.ticker.lagSmoothing(0);

      // Expose lenis globally for snap control
      (window as any).__lenis = lenis;

      // ---- Fade-in elements ----
      document.querySelectorAll<HTMLElement>('.fade-up').forEach((el) => {
        gsap.fromTo(
          el,
          { opacity: 0, y: 40 },
          {
            opacity: 1,
            y: 0,
            duration: 1,
            ease: 'power2.out',
            scrollTrigger: {
              trigger: el,
              start: 'top 85%',
            },
          }
        );
      });

      // ---- Stagger cards ----
      document.querySelectorAll<HTMLElement>('.stagger-group').forEach((group) => {
        const items = group.querySelectorAll('.stagger-item');
        gsap.fromTo(
          items,
          { opacity: 0, y: 30 },
          {
            opacity: 1,
            y: 0,
            duration: 0.7,
            stagger: 0.12,
            ease: 'power2.out',
            scrollTrigger: {
              trigger: group,
              start: 'top 80%',
            },
          }
        );
      });

      // ---- Gallery reveal ----
      document.querySelectorAll<HTMLElement>('.gallery-item').forEach((item, i) => {
        gsap.fromTo(
          item,
          { opacity: 0, scale: 0.95 },
          {
            opacity: 1,
            scale: 1,
            duration: 0.6,
            delay: i * 0.08,
            ease: 'power2.out',
            scrollTrigger: {
              trigger: item,
              start: 'top 88%',
            },
          }
        );
      });

      // ---- Countdown ----
      function updateCountdown() {
        const partyDate = new Date('2026-09-19T13:00:00Z').getTime();
        const now = new Date().getTime();
        const diff = partyDate - now;

        if (diff <= 0) {
          const el = document.getElementById('countdown');
          if (el) el.innerHTML = '<span class="font-mono text-2xl text-white/60">Jetzt.</span>';
          return;
        }

        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        const setVal = (id: string, val: number) => {
          const el = document.getElementById(id);
          if (el) el.textContent = String(val).padStart(2, '0');
        };

        setVal('cd-days', days);
        setVal('cd-hours', hours);
        setVal('cd-minutes', minutes);
        setVal('cd-seconds', seconds);
      }

      updateCountdown();
      setInterval(updateCountdown, 1000);

      // ---- Map + Horizontal Timeline ----
      const timetable = document.getElementById('timetable');
      const mapEl = document.getElementById('map');
      const timelineTrack = document.getElementById('timeline-track');
      const timelineTrackWrapper = document.getElementById('timeline-track-wrapper');
      const progressBar = document.getElementById('timeline-progress');

      if (timetable && mapEl && timelineTrack && timelineTrackWrapper) {
        import('leaflet').then((L) => {
          const isMobile = window.innerWidth < 768;

          // Hamburg locations
          // stop 0 = Intro, 1 = Strandperle, 2 = Elbe image, 3 = Walk, 4 = Museumshafen image, 5 = Barkasse, 6 = Boat photo, 7 = Boat photo, 8 = LandungsbrÃ¼cken, 9 = Portugiesenviertel image, 10 = La Cocina
          const stops = [
            { name: 'Ãœbersicht', lat: 53.5465, lng: 9.9400, zoom: isMobile ? 12.5 : 13.5 },
            { name: 'Strandperle', lat: 53.5445, lng: 9.9055, zoom: isMobile ? 15.5 : 16.5 },
            { name: 'Strandperle', lat: 53.5445, lng: 9.9055, zoom: isMobile ? 15.5 : 16.5 },
            { name: 'Anleger Ã–velgÃ¶nne', lat: 53.5441122, lng: 9.9120346, zoom: isMobile ? 16 : 17 },
            { name: 'Museumshafen', lat: 53.5441122, lng: 9.9120346, zoom: isMobile ? 16 : 17 },
            { name: 'Anleger Ã–velgÃ¶nne', lat: 53.5441122, lng: 9.9120346, zoom: isMobile ? 14 : 15 },
            { name: 'Auf der Elbe', lat: 53.5424, lng: 9.9330, zoom: isMobile ? 13 : 14 },
            { name: 'Hamburger Hafen', lat: 53.5431, lng: 9.9510, zoom: isMobile ? 13 : 14 },
            { name: 'LandungsbrÃ¼cken', lat: 53.5451, lng: 9.9631, zoom: isMobile ? 14 : 15 },
            { name: 'Portugiesenviertel', lat: 53.5470, lng: 9.9740, zoom: isMobile ? 15 : 16 },
            { name: 'La Cocina', lat: 53.5494, lng: 9.9739, zoom: isMobile ? 15 : 16 },
          ];

          // Routes
          const strandperleWalkRoute: [number, number][] = [
            [53.5445, 9.9055], [53.5444, 9.9070], [53.5443, 9.9085],
            [53.5442, 9.9100], [53.5441122, 9.9120346],
          ];

          const barkasseRoute: [number, number][] = [
            [53.5441122, 9.9120346], [53.5435, 9.9160], [53.5428, 9.9220],
            [53.5424, 9.9280], [53.5422, 9.9330], [53.5421, 9.9370],
            [53.5422, 9.9410], [53.5424, 9.9445], [53.5427, 9.9480],
            [53.5431, 9.9510], [53.5435, 9.9540], [53.5440, 9.9570],
            [53.5445, 9.9600], [53.5449, 9.9620], [53.5451, 9.9631],
          ];

          const walkRoute: [number, number][] = [
            [53.5451, 9.9631], [53.5453, 9.9650], [53.5455, 9.9675],
            [53.5458, 9.9700], [53.5455, 9.9720], [53.5460, 9.9735],
            [53.5470, 9.9740], [53.5480, 9.9738], [53.5490, 9.9739],
            [53.5494, 9.9739],
          ];

          // Create map
          const map = L.map(mapEl, {
            center: [53.5465, 9.9400],
            zoom: isMobile ? 12.5 : 13.5,
            zoomControl: false,
            attributionControl: false,
            scrollWheelZoom: false,
            dragging: false,
            tap: false,
            doubleClickZoom: false,
            touchZoom: false,
            keyboard: false,
          });

          setTimeout(() => map.invalidateSize(), 300);
          const resizeObserver = new ResizeObserver(() => map.invalidateSize());
          resizeObserver.observe(mapEl);

          L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
            subdomains: 'abcd',
            maxZoom: 19,
          }).addTo(map);

          // Add labels as separate layer
          L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_only_labels/{z}/{x}/{y}{r}.png', {
            subdomains: 'abcd',
            maxZoom: 19,
            opacity: 0.6,
          }).addTo(map);

          // Marker icons
          const createIcon = (active: boolean) =>
            L.divIcon({
              className: 'custom-marker',
              html: `<div style="
                width: ${active ? '14px' : '8px'};
                height: ${active ? '14px' : '8px'};
                background: ${active ? '#c2703e' : 'rgba(26,29,46,0.2)'};
                border: 2px solid ${active ? '#d4874f' : 'rgba(26,29,46,0.3)'};
                border-radius: 50%;
                box-shadow: ${active ? '0 0 12px rgba(194,112,62,0.35)' : 'none'};
                transition: all 0.5s ease;
              "></div>`,
              iconSize: [active ? 14 : 8, active ? 14 : 8],
              iconAnchor: [active ? 7 : 4, active ? 7 : 4],
            });

          // Place markers (skip intro index 0 and walk index 2)
          // Initially hidden â€” revealed progressively
          const markerIndices = [1, 5, 8, 10];
          const markers: { [key: number]: any } = {};
          markerIndices.forEach((si) => {
            const stop = stops[si];
            const marker = L.marker([stop.lat, stop.lng], {
              icon: createIcon(false),
            }).addTo(map);
            // Hide initially via DOM element (divIcon doesn't support opacity option well)
            setTimeout(() => {
              const el = marker.getElement();
              if (el) { el.style.opacity = '0'; el.style.transition = 'opacity 0.4s ease'; }
            }, 0);
            marker.bindTooltip(stop.name, {
              permanent: false,
              direction: 'top',
              className: 'map-tooltip',
              offset: [0, -8],
            });
            markers[si] = marker;
          });

          // Draw faint dashed route previews â€” hidden initially, shown as stops activate
          const barkasseLine = L.polyline(barkasseRoute, { color: '#c2703e', weight: 2, opacity: 0, dashArray: '8, 8' }).addTo(map);
          const walkLine = L.polyline(walkRoute, { color: '#6b7084', weight: 1.5, opacity: 0, dashArray: '4, 6' }).addTo(map);
          const strandperleWalkLine = L.polyline(strandperleWalkRoute, { color: '#6b7084', weight: 1.5, opacity: 0, dashArray: '4, 6' }).addTo(map);

          // Walk marker
          const walkIcon = L.divIcon({
            className: 'walk-marker',
            html: `<div style="font-size:22px;line-height:1;filter:drop-shadow(0 1px 3px rgba(26,29,46,0.2));animation:walkBounce 0.6s ease-in-out infinite alternate;">ðŸš¶</div>`,
            iconSize: [22, 22],
            iconAnchor: [11, 22],
          });
          const walkMarker = L.marker(strandperleWalkRoute[0], { icon: walkIcon });

          // Walk2 marker (LandungsbrÃ¼cken â†’ La Cocina)
          const walk2Icon = L.divIcon({
            className: 'walk-marker',
            html: `<div style="font-size:22px;line-height:1;filter:drop-shadow(0 1px 3px rgba(26,29,46,0.2));animation:walkBounce 0.6s ease-in-out infinite alternate;">ðŸš¶</div>`,
            iconSize: [22, 22],
            iconAnchor: [11, 22],
          });
          const walk2Marker = L.marker(walkRoute[0], { icon: walk2Icon });

          // Boat marker
          const boatIcon = L.divIcon({
            className: 'boat-marker',
            html: `<div style="font-size:22px;line-height:1;filter:drop-shadow(0 1px 3px rgba(26,29,46,0.2));animation:walkBounce 1.2s ease-in-out infinite alternate;">ðŸš¢</div>`,
            iconSize: [22, 22],
            iconAnchor: [11, 22],
          });
          const boatMarker = L.marker(barkasseRoute[0], { icon: boatIcon });

          // Interpolate along route
          function interpolateRoute(route: [number, number][], progress: number): { points: [number, number][], position: [number, number] } {
            if (progress <= 0) return { points: [route[0]], position: route[0] };
            if (progress >= 1) return { points: [...route], position: route[route.length - 1] };
            let totalDist = 0;
            const segDists: number[] = [];
            for (let i = 1; i < route.length; i++) {
              const d = Math.sqrt(Math.pow(route[i][0] - route[i - 1][0], 2) + Math.pow(route[i][1] - route[i - 1][1], 2));
              segDists.push(d);
              totalDist += d;
            }
            const targetDist = progress * totalDist;
            let traveled = 0;
            const result: [number, number][] = [route[0]];
            for (let i = 0; i < segDists.length; i++) {
              if (traveled + segDists[i] >= targetDist) {
                const frac = (targetDist - traveled) / segDists[i];
                const lat = route[i][0] + frac * (route[i + 1][0] - route[i][0]);
                const lng = route[i][1] + frac * (route[i + 1][1] - route[i][1]);
                result.push([lat, lng]);
                return { points: result, position: [lat, lng] };
              }
              traveled += segDists[i];
              result.push(route[i + 1]);
            }
            return { points: route, position: route[route.length - 1] };
          }

          // ---- Horizontal timeline (new approach: sticky + tall section) ----
          const timelineStops = document.querySelectorAll<HTMLElement>('.timeline-stop');
          const timelineDots = document.querySelectorAll<HTMLElement>('.timeline-dot');
          const totalCards = timelineStops.length;
          const getMaxScroll = () => timelineTrack.scrollWidth - window.innerWidth;

          // Set section height â€” creates vertical scroll space mapped to horizontal movement
          // Each card gets ~130vh of scroll, so movement feels leisurely
          function setSectionHeight() {
            const vh = window.innerHeight;
            timetable!.style.height = `${totalCards * vh * 1.3}px`;
          }
          setSectionHeight();

          // Compute snap points as 0â€“1 progress values (center each card in viewport)
          function computeSnapPoints(): number[] {
            const maxScroll = getMaxScroll();
            if (maxScroll <= 0) return Array.from({ length: totalCards }, (_, i) => i / Math.max(1, totalCards - 1));
            return Array.from(timelineStops).map((card) => {
              const el = card as HTMLElement;
              const center = el.offsetLeft + el.offsetWidth / 2;
              const snapScroll = center - window.innerWidth / 2;
              return Math.max(0, Math.min(1, snapScroll / maxScroll));
            });
          }

          // ---- Scroll-linked horizontal movement ----
          // scrub: 0.3 adds slight smoothing to prevent micro-jank from raw scroll events
          gsap.to(timelineTrack, {
            x: () => -getMaxScroll(),
            ease: 'none',
            scrollTrigger: {
              trigger: timetable,
              start: 'top top',
              end: 'bottom bottom',
              scrub: 0.3,
              invalidateOnRefresh: true,
              onUpdate: (self) => {
                const progress = self.progress;
                const maxScroll = getMaxScroll();
                const scrollPos = progress * maxScroll;

                // Progress bar â€” direct DOM, no GSAP overhead
                if (progressBar) {
                  progressBar.style.width = `${(progress * 100).toFixed(1)}%`;
                }

                // Active card: whose center is closest to viewport center
                const viewCenter = scrollPos + window.innerWidth / 2;
                let activeIndex = 0;
                let minCardDist = Infinity;
                timelineStops.forEach((card, i) => {
                  const el = card as HTMLElement;
                  const cardCenter = el.offsetLeft + el.offsetWidth / 2;
                  const dist = Math.abs(viewCenter - cardCenter);
                  if (dist < minCardDist) {
                    minCardDist = dist;
                    activeIndex = i;
                  }
                });

                activateStop(activeIndex);

                // Walk animation at stop 3, completes before stop 4
                if (activeIndex >= 3 && activeIndex <= 4) {
                  const card3 = timelineStops[3] as HTMLElement;
                  const spanStart = card3.offsetLeft;
                  const spanEnd = spanStart + card3.offsetWidth;
                  const viewPos = scrollPos + window.innerWidth * 0.5;
                  const walkProg = Math.max(0, Math.min(1, (viewPos - spanStart) / (spanEnd - spanStart)));
                  if (!(walkMarker as any)._map) walkMarker.addTo(map);
                  const { points, position } = interpolateRoute(strandperleWalkRoute, walkProg);
                  walkMarker.setLatLng(position);
                  const walkEl = (walkMarker as any).getElement();
                  if (walkEl) walkEl.style.opacity = '1';
                } else {
                  if (activeIndex > 4) {
                  } else {
                  }
                  if ((walkMarker as any)._map) walkMarker.remove();
                }

                // Boat animation at stops 5-7 (Barkasse + 2 boat photo cards)
                if (activeIndex >= 5 && activeIndex <= 7) {
                  const card5 = timelineStops[5] as HTMLElement;
                  const card7 = timelineStops[7] as HTMLElement;
                  const spanStart = card5.offsetLeft;
                  const spanEnd = card7.offsetLeft + card7.offsetWidth;
                  const viewPos = scrollPos + window.innerWidth * 0.5;
                  const boatProg = Math.max(0, Math.min(1, (viewPos - spanStart) / (spanEnd - spanStart)));
                  if (!(boatMarker as any)._map) boatMarker.addTo(map);
                  const { points, position } = interpolateRoute(barkasseRoute, boatProg);
                  boatMarker.setLatLng(position);
                  const boatEl = (boatMarker as any).getElement();
                  if (boatEl) boatEl.style.opacity = '1';
                } else {
                  if (activeIndex > 7) {
                  } else {
                  }
                  if ((boatMarker as any)._map) boatMarker.remove();
                }

                // Walk2 animation at stops 8-9 (LandungsbrÃ¼cken + Portugiesenviertel)
                if (activeIndex >= 8 && activeIndex <= 9) {
                  const card8 = timelineStops[8] as HTMLElement;
                  const card9 = timelineStops[9] as HTMLElement;
                  const spanStart = card8.offsetLeft;
                  const spanEnd = card9.offsetLeft + card9.offsetWidth;
                  const viewPos = scrollPos + window.innerWidth * 0.5;
                  const walk2Prog = Math.max(0, Math.min(1, (viewPos - spanStart) / (spanEnd - spanStart)));
                  if (!(walk2Marker as any)._map) walk2Marker.addTo(map);
                  const { points, position } = interpolateRoute(walkRoute, walk2Prog);
                  walk2Marker.setLatLng(position);
                  const walk2El = (walk2Marker as any).getElement();
                  if (walk2El) walk2El.style.opacity = '1';
                } else {
                  if (activeIndex > 9) {
                  } else {
                  }
                  if ((walk2Marker as any)._map) walk2Marker.remove();
                }
              },
            },
          });

          // ---- Lenis-driven snap: settle onto nearest card when scrolling stops ----
          let snapTimer: ReturnType<typeof setTimeout>;
          let isSnapping = false;
          let snapEnabled = false; // Disable snap for the initial scroll into the timeline

          function snapToNearestCard() {
            if (!snapEnabled) return;
            const allTriggers = ScrollTrigger.getAll();
            const st = allTriggers.find((s) => s.vars.trigger === timetable);
            if (!st || !st.isActive) return;

            const snapPoints = computeSnapPoints();
            const current = st.progress;

            // Enable snap only after scrolling past the intro card
            if (!snapEnabled) return;

            // Find nearest snap point
            let nearest = snapPoints[0];
            let minDist = Math.abs(current - nearest);
            for (const p of snapPoints) {
              const dist = Math.abs(current - p);
              if (dist < minDist) { minDist = dist; nearest = p; }
            }

            if (minDist < 0.003) return; // Already close enough

            // Scroll to the target position using Lenis for smooth animation
            const targetScroll = st.start + nearest * (st.end - st.start);
            isSnapping = true;
            lenis.scrollTo(targetScroll, {
              duration: 1.0,
              easing: (t: number) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2),
              onComplete: () => { isSnapping = false; },
            });
          }

          function scheduleSnap() {
            if (isSnapping || !snapEnabled) return;
            clearTimeout(snapTimer);
            snapTimer = setTimeout(snapToNearestCard, 200);
          }

          // Enable snap once user scrolls past the intro card
          function checkSnapEnable() {
            if (snapEnabled) return;
            const allTriggers = ScrollTrigger.getAll();
            const st = allTriggers.find((s) => s.vars.trigger === timetable);
            if (!st || !st.isActive) return;
            const snapPoints = computeSnapPoints();
            // Enable after progressing past the midpoint between intro (0) and first station (1)
            if (snapPoints.length >= 2 && st.progress > (snapPoints[0] + snapPoints[1]) / 2) {
              snapEnabled = true;
            }
          }

          // Snap after wheel activity stops
          window.addEventListener('wheel', () => {
            if (isSnapping) { isSnapping = false; }
            checkSnapEnable();
            scheduleSnap();
          }, { passive: true });

          // Snap after touch ends (longer delay for momentum)
          window.addEventListener('touchend', () => {
            checkSnapEnable();
            clearTimeout(snapTimer);
            if (snapEnabled) {
              snapTimer = setTimeout(snapToNearestCard, 400);
            }
          }, { passive: true });

          // ---- Stop activation ----
          let currentStop = -1;
          let flyToTimeout: ReturnType<typeof setTimeout>;

          function activateStop(index: number) {
            if (index === currentStop) return;
            currentStop = index;

            // Debounce map flyTo â€” prevents rapid successive calls during fast scroll
            clearTimeout(flyToTimeout);
            flyToTimeout = setTimeout(() => {
              const stop = stops[index];
              map.flyTo([stop.lat, stop.lng], stop.zoom, {
                duration: 1.0,
                easeLinearity: 0.25,
              });
            }, 80);


            // Progressive route reveal
            strandperleWalkLine.setStyle({ opacity: index >= 3 ? 0.15 : 0 });
            barkasseLine.setStyle({ opacity: index >= 5 ? 0.35 : 0 });
            walkLine.setStyle({ opacity: index >= 8 ? 0.2 : 0 });

            // Progressive marker reveal
            const activeMarkerIndex = index === 0 ? -1 : (index <= 2 ? 1 : index <= 7 ? 5 : index <= 9 ? 8 : index);
            Object.keys(markers).forEach((key) => {
              const ki = parseInt(key);
              const shouldShow = (ki === 1 && index >= 1) ||
                (ki === 5 && index >= 3) ||
                (ki === 8 && index >= 8) ||
                (ki === 10 && index >= 10);
              const el = markers[ki].getElement();
              if (el) el.style.opacity = shouldShow ? '1' : '0';
              if (shouldShow) {
                markers[ki].setIcon(createIcon(ki === activeMarkerIndex));
              }
            });

            // Update dots (dots array starts at card 1, so dot index = card index - 1)
            const activeDotIndex = index - 1;
            timelineDots.forEach((dot, i) => {
              if (i === activeDotIndex) {
                dot.classList.remove('border-[#c8cad4]');
                dot.classList.add('border-[#c2703e]');
                dot.style.background = 'rgba(194, 112, 62, 0.15)';
                dot.style.transform = 'scale(1.4)';
              } else {
                dot.classList.add('border-[#c8cad4]');
                dot.classList.remove('border-[#c2703e]');
                dot.style.background = '#f4f1ec';
                dot.style.transform = 'scale(1)';
              }
            });

            // Update card opacity â€” use CSS directly instead of GSAP tweens
            timelineStops.forEach((el, i) => {
              (el as HTMLElement).style.opacity = i === index ? '1' : '0.5';
            });
          }

          // Initial state
          activateStop(0);
          timelineStops.forEach((el, i) => {
            if (i !== 0) (el as HTMLElement).style.opacity = '0.3';
          });

          // Recalculate on resize
          window.addEventListener('resize', () => {
            setSectionHeight();
            ScrollTrigger.refresh();
            map.invalidateSize();
          });
        });
      }
    </script>
  </body>
</html>
